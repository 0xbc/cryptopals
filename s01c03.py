import codecs

# expected distribution of A-Z
freqs = [
    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,
    0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,
    0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,
    0.00978, 0.02360, 0.00150, 0.01974, 0.00074
]

cipher = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'
cipher_bytes = codecs.decode(cipher, 'hex').strip()

chsqs = {}
# loop through each possible key, A-Z
for k in range(ord('A'), ord('A')+26):

    # generate the plaintext generated by that key, count the number of letters in it
    pt = ''.join(chr(ord(a) ^ k) for a in cipher_bytes).upper()
    numalpha = len([c for c in pt if c.isalpha()])

    # calculate the chi-square to estimate goodness of fit
    chsq = 0
    for c in range(ord('A'), ord('A')+26):
        nobs = len([ch for ch in pt if ch == chr(c)])
        nexp = freqs[c - ord('A')] * numalpha
        chsq = chsq + (nobs - nexp) ** 2 / nexp

    chsqs[k] = chsq

# choose the key that generated the smallest value (== best fit)
chosen_char = min(chsqs, key=chsqs.get)
print ''.join(chr(ord(a) ^ chosen_char) for a in cipher_bytes)

